webpackHotUpdate_N_E("pages/tooltip",{

/***/ "../../node_modules/raw-loader/dist/cjs.js!./src/sandboxes/visx-tooltip/Example.tsx":
/*!**********************************************************************************************************!*\
  !*** /Users/harry/dev/visx/node_modules/raw-loader/dist/cjs.js!./src/sandboxes/visx-tooltip/Example.tsx ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"import React, { useState, useCallback } from 'react';\\nimport {\\n  Tooltip,\\n  TooltipWithBounds,\\n  useTooltip,\\n  useTooltipInPortal,\\n  defaultStyles,\\n} from '@visx/tooltip';\\n\\nexport type TooltipProps = {\\n  width: number;\\n  height: number;\\n  showControls?: boolean;\\n};\\n\\ntype TooltipData = string;\\n\\nconst positionIndicatorSize = 8;\\n\\nconst tooltipStyles = {\\n  ...defaultStyles,\\n  backgroundColor: 'rgba(53,71,125,0.8)',\\n  color: 'white',\\n  width: 152,\\n  height: 72,\\n  padding: 12,\\n};\\n\\nexport default function Example({ width, height, showControls = true }: TooltipProps) {\\n  const [tooltipShouldDetectBounds, setTooltipShouldDetectBounds] = useState(true);\\n  const [renderTooltipInPortal, setRenderTooltipInPortal] = useState(false);\\n\\n  const { containerRef, containerBounds, TooltipInPortal } = useTooltipInPortal({\\n    scroll: true,\\n    detectBounds: tooltipShouldDetectBounds,\\n  });\\n\\n  const {\\n    showTooltip,\\n    hideTooltip,\\n    tooltipOpen,\\n    tooltipData,\\n    tooltipLeft = 0,\\n    tooltipTop = 0,\\n  } = useTooltip<TooltipData>({\\n    // initial tooltip state\\n    tooltipOpen: true,\\n    tooltipLeft: width / 3,\\n    tooltipTop: height / 3,\\n    tooltipData: 'Move me with your mouse or finger',\\n  });\\n\\n  // event handlers\\n  const handleMouseMove = useCallback(\\n    (event: React.MouseEvent | React.TouchEvent) => {\\n      // coordinates should be relative to the container in which Tooltip is rendered\\n      const containerX = ('clientX' in event ? event.clientX : 0) - containerBounds.left;\\n      const containerY = ('clientY' in event ? event.clientY : 0) - containerBounds.top;\\n\\n      showTooltip({\\n        tooltipLeft: containerX,\\n        tooltipTop: containerY,\\n        tooltipData: tooltipShouldDetectBounds\\n          ? 'I detect my container boundary'\\n          : 'I will get clipped by my container',\\n      });\\n    },\\n    [showTooltip, tooltipShouldDetectBounds, containerBounds],\\n  );\\n\\n  const TooltipComponent = renderTooltipInPortal\\n    ? TooltipInPortal\\n    : tooltipShouldDetectBounds\\n    ? TooltipWithBounds\\n    : Tooltip;\\n\\n  return (\\n    <>\\n      <div\\n        ref={containerRef}\\n        className=\\\"tooltip-example\\\"\\n        style={{ width, height }}\\n        onMouseMove={handleMouseMove}\\n        onTouchMove={handleMouseMove}\\n        onDrag={e => e.stopPropagation()}\\n      >\\n        {tooltipOpen ? (\\n          <>\\n            <div\\n              className=\\\"position-indicator\\\"\\n              style={{\\n                transform: `translate(${tooltipLeft - positionIndicatorSize / 2}px, ${tooltipTop -\\n                  positionIndicatorSize / 2}px)`,\\n              }}\\n            />\\n            <div\\n              className=\\\"crosshair horizontal\\\"\\n              style={{ transform: `translateY(${tooltipTop}px)` }}\\n            />\\n            <div\\n              className=\\\"crosshair vertical\\\"\\n              style={{ transform: `translateX(${tooltipLeft}px)` }}\\n            />\\n            <TooltipComponent\\n              key={Math.random()} // needed for bounds to update correctly\\n              left={tooltipLeft}\\n              top={tooltipTop}\\n              style={tooltipStyles}\\n            >\\n              {tooltipData}\\n              <br />\\n              <br />\\n              <strong>left</strong> {tooltipLeft?.toFixed(0)}px&nbsp;&nbsp;\\n              <strong>top</strong> {tooltipTop?.toFixed(0)}px\\n            </TooltipComponent>\\n          </>\\n        ) : (\\n          <div className=\\\"no-tooltip\\\">Move or touch the canvas to see the tooltip</div>\\n        )}\\n        <div className=\\\"z-index-bummer\\\">\\n          I have an annoying z-index. Try&nbsp;\\n          <label>\\n            <input\\n              type=\\\"checkbox\\\"\\n              defaultChecked={renderTooltipInPortal}\\n              onClick={e => {\\n                // if rendered in clickable container, don't trigger that event\\n                e.stopPropagation();\\n                setRenderTooltipInPortal(!renderTooltipInPortal);\\n              }}\\n            />\\n            &nbsp;rendering in Portal\\n          </label>\\n          &nbsp;\\n          <span role=\\\"img\\\" aria-label=\\\"yay\\\">\\n            ðŸ¥³\\n          </span>\\n        </div>\\n      </div>\\n      {showControls && (\\n        <div className=\\\"tooltip-controls\\\">\\n          <label>\\n            <input\\n              type=\\\"checkbox\\\"\\n              checked={tooltipShouldDetectBounds}\\n              onChange={() => setTooltipShouldDetectBounds(!tooltipShouldDetectBounds)}\\n            />\\n            &nbsp;Tooltip with boundary detection\\n          </label>\\n\\n          <button onClick={() => hideTooltip()}>Hide tooltip</button>\\n        </div>\\n      )}\\n      <style>{`\\n        .tooltip-example {\\n          z-index: 0;\\n          position: relative;\\n          overflow: hidden;\\n          border-radius: 16px;\\n          background: linear-gradient(45deg, #6c5b7b, #c06c84, #f67280);\\n          font-size: 14px;\\n          color: white;\\n          width: 100%;\\n          height: 100%;\\n        }\\n        .tooltip-controls label {\\n          font-size: 14px;\\n          margin-right: 8px;\\n        }\\n        .position-indicator {\\n          width: ${positionIndicatorSize}px;\\n          height: ${positionIndicatorSize}px;\\n          border-radius: 50%;\\n          background: #35477d;\\n          position: absolute;\\n        }\\n        .crosshair {\\n          position: absolute;\\n          top: 0;\\n          left: 0;\\n        }\\n        .crosshair.horizontal {\\n          width: 100%;\\n          height: 1px;\\n          border-top: 1px dashed #35477d;\\n        }\\n        .crosshair.vertical {\\n          height: 100%;\\n          width: 1px;\\n          border-left: 1px dashed #35477d;\\n        }\\n        .no-tooltip {\\n          position: absolute;\\n          left: 50%;\\n          top: 50%;\\n          transform: translate(-50%, -50%);\\n        }\\n        .z-index-bummer {\\n          position: absolute;\\n          right: 12%;\\n          bottom: 20%;\\n          max-width: 190px;\\n          z-index: 2000;\\n          background: rgba(255, 255, 255, 0.8);\\n          color: #35477d;\\n          border-radius: 8px;\\n          padding: 16px;\\n          line-height: 1.2em;\\n        }\\n      `}</style>\\n    </>\\n  );\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NhbmRib3hlcy92aXN4LXRvb2x0aXAvRXhhbXBsZS50c3g/OTQ2OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLCtFQUFnQix3QkFBd0IsY0FBYyxVQUFVLDZGQUE2RixzQkFBc0IsZ0NBQWdDLGtCQUFrQixtQkFBbUIsMkJBQTJCLElBQUksOEJBQThCLG9DQUFvQywyQkFBMkIscUlBQXFJLHFDQUFxQyxxQ0FBcUMsaUJBQWlCLHFGQUFxRiw4RUFBOEUsYUFBYSxpREFBaUQsdUJBQXVCLHNFQUFzRSxFQUFFLGFBQWEsd0hBQXdILDRCQUE0Qiw0S0FBNEssRUFBRSxzSEFBc0gsa0xBQWtMLDBGQUEwRix1QkFBdUIsNk5BQTZOLEVBQUUsT0FBTyx1RUFBdUUscUpBQXFKLGlEQUFpRCxhQUFhLHlEQUF5RCxpQkFBaUIsdUJBQXVCLGdCQUFnQix1QkFBdUIsZ0JBQWdCLGtCQUFrQix5QkFBeUIsb0JBQW9CLHVIQUF1SCwwQ0FBMEMsd0NBQXdDLE1BQU0sMERBQTBELHVCQUF1Qiw0R0FBNEcsMEJBQTBCLFdBQVcsT0FBTywwR0FBMEcsMEJBQTBCLFlBQVksT0FBTyxvRUFBb0UsY0FBYywrREFBK0QsWUFBWSxxQkFBcUIsV0FBVyx1QkFBdUIsY0FBYyxnQ0FBZ0MsWUFBWSxtRkFBbUYsd0JBQXdCLFFBQVEsTUFBTSxzQ0FBc0MsdUJBQXVCLHdLQUF3Syw2RkFBNkYsd0dBQXdHLHNCQUFzQix5QkFBeUIsTUFBTSx1SEFBdUgsbUVBQW1FLGtCQUFrQixvQ0FBb0MseURBQXlELDRIQUE0SCxnS0FBZ0ssMEJBQTBCLDBCQUEwQiwrREFBK0Qsb0NBQW9DLGtGQUFrRixvQkFBb0IsZ0RBQWdELGdCQUFnQiw2QkFBNkIsdUJBQXVCLCtCQUErQiw2QkFBNkIsZ0NBQWdDLDBFQUEwRSw0QkFBNEIseUJBQXlCLHdCQUF3Qix5QkFBeUIsV0FBVyxtQ0FBbUMsNEJBQTRCLDhCQUE4QixXQUFXLCtCQUErQixxQkFBcUIsc0JBQXNCLEdBQUcsc0JBQXNCLHNCQUFzQixHQUFHLCtCQUErQixnQ0FBZ0MsK0JBQStCLFdBQVcsc0JBQXNCLCtCQUErQixtQkFBbUIsb0JBQW9CLFdBQVcsaUNBQWlDLHdCQUF3Qix3QkFBd0IsMkNBQTJDLFdBQVcsK0JBQStCLHlCQUF5Qix1QkFBdUIsNENBQTRDLFdBQVcsdUJBQXVCLCtCQUErQixzQkFBc0IscUJBQXFCLDZDQUE2QyxXQUFXLDJCQUEyQiwrQkFBK0IsdUJBQXVCLHdCQUF3Qiw2QkFBNkIsMEJBQTBCLGlEQUFpRCwyQkFBMkIsK0JBQStCLDBCQUEwQiwrQkFBK0IsV0FBVyxVQUFVLHVCQUF1QixHQUFHLEdBQUciLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvc2FuZGJveGVzL3Zpc3gtdG9vbHRpcC9FeGFtcGxlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcXG5pbXBvcnQge1xcbiAgVG9vbHRpcCxcXG4gIFRvb2x0aXBXaXRoQm91bmRzLFxcbiAgdXNlVG9vbHRpcCxcXG4gIHVzZVRvb2x0aXBJblBvcnRhbCxcXG4gIGRlZmF1bHRTdHlsZXMsXFxufSBmcm9tICdAdmlzeC90b29sdGlwJztcXG5cXG5leHBvcnQgdHlwZSBUb29sdGlwUHJvcHMgPSB7XFxuICB3aWR0aDogbnVtYmVyO1xcbiAgaGVpZ2h0OiBudW1iZXI7XFxuICBzaG93Q29udHJvbHM/OiBib29sZWFuO1xcbn07XFxuXFxudHlwZSBUb29sdGlwRGF0YSA9IHN0cmluZztcXG5cXG5jb25zdCBwb3NpdGlvbkluZGljYXRvclNpemUgPSA4O1xcblxcbmNvbnN0IHRvb2x0aXBTdHlsZXMgPSB7XFxuICAuLi5kZWZhdWx0U3R5bGVzLFxcbiAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1Myw3MSwxMjUsMC44KScsXFxuICBjb2xvcjogJ3doaXRlJyxcXG4gIHdpZHRoOiAxNTIsXFxuICBoZWlnaHQ6IDcyLFxcbiAgcGFkZGluZzogMTIsXFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFeGFtcGxlKHsgd2lkdGgsIGhlaWdodCwgc2hvd0NvbnRyb2xzID0gdHJ1ZSB9OiBUb29sdGlwUHJvcHMpIHtcXG4gIGNvbnN0IFt0b29sdGlwU2hvdWxkRGV0ZWN0Qm91bmRzLCBzZXRUb29sdGlwU2hvdWxkRGV0ZWN0Qm91bmRzXSA9IHVzZVN0YXRlKHRydWUpO1xcbiAgY29uc3QgW3JlbmRlclRvb2x0aXBJblBvcnRhbCwgc2V0UmVuZGVyVG9vbHRpcEluUG9ydGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcXG5cXG4gIGNvbnN0IHsgY29udGFpbmVyUmVmLCBjb250YWluZXJCb3VuZHMsIFRvb2x0aXBJblBvcnRhbCB9ID0gdXNlVG9vbHRpcEluUG9ydGFsKHtcXG4gICAgc2Nyb2xsOiB0cnVlLFxcbiAgICBkZXRlY3RCb3VuZHM6IHRvb2x0aXBTaG91bGREZXRlY3RCb3VuZHMsXFxuICB9KTtcXG5cXG4gIGNvbnN0IHtcXG4gICAgc2hvd1Rvb2x0aXAsXFxuICAgIGhpZGVUb29sdGlwLFxcbiAgICB0b29sdGlwT3BlbixcXG4gICAgdG9vbHRpcERhdGEsXFxuICAgIHRvb2x0aXBMZWZ0ID0gMCxcXG4gICAgdG9vbHRpcFRvcCA9IDAsXFxuICB9ID0gdXNlVG9vbHRpcDxUb29sdGlwRGF0YT4oe1xcbiAgICAvLyBpbml0aWFsIHRvb2x0aXAgc3RhdGVcXG4gICAgdG9vbHRpcE9wZW46IHRydWUsXFxuICAgIHRvb2x0aXBMZWZ0OiB3aWR0aCAvIDMsXFxuICAgIHRvb2x0aXBUb3A6IGhlaWdodCAvIDMsXFxuICAgIHRvb2x0aXBEYXRhOiAnTW92ZSBtZSB3aXRoIHlvdXIgbW91c2Ugb3IgZmluZ2VyJyxcXG4gIH0pO1xcblxcbiAgLy8gZXZlbnQgaGFuZGxlcnNcXG4gIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IHVzZUNhbGxiYWNrKFxcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQgfCBSZWFjdC5Ub3VjaEV2ZW50KSA9PiB7XFxuICAgICAgLy8gY29vcmRpbmF0ZXMgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgaW4gd2hpY2ggVG9vbHRpcCBpcyByZW5kZXJlZFxcbiAgICAgIGNvbnN0IGNvbnRhaW5lclggPSAoJ2NsaWVudFgnIGluIGV2ZW50ID8gZXZlbnQuY2xpZW50WCA6IDApIC0gY29udGFpbmVyQm91bmRzLmxlZnQ7XFxuICAgICAgY29uc3QgY29udGFpbmVyWSA9ICgnY2xpZW50WScgaW4gZXZlbnQgPyBldmVudC5jbGllbnRZIDogMCkgLSBjb250YWluZXJCb3VuZHMudG9wO1xcblxcbiAgICAgIHNob3dUb29sdGlwKHtcXG4gICAgICAgIHRvb2x0aXBMZWZ0OiBjb250YWluZXJYLFxcbiAgICAgICAgdG9vbHRpcFRvcDogY29udGFpbmVyWSxcXG4gICAgICAgIHRvb2x0aXBEYXRhOiB0b29sdGlwU2hvdWxkRGV0ZWN0Qm91bmRzXFxuICAgICAgICAgID8gJ0kgZGV0ZWN0IG15IGNvbnRhaW5lciBib3VuZGFyeSdcXG4gICAgICAgICAgOiAnSSB3aWxsIGdldCBjbGlwcGVkIGJ5IG15IGNvbnRhaW5lcicsXFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIFtzaG93VG9vbHRpcCwgdG9vbHRpcFNob3VsZERldGVjdEJvdW5kcywgY29udGFpbmVyQm91bmRzXSxcXG4gICk7XFxuXFxuICBjb25zdCBUb29sdGlwQ29tcG9uZW50ID0gcmVuZGVyVG9vbHRpcEluUG9ydGFsXFxuICAgID8gVG9vbHRpcEluUG9ydGFsXFxuICAgIDogdG9vbHRpcFNob3VsZERldGVjdEJvdW5kc1xcbiAgICA/IFRvb2x0aXBXaXRoQm91bmRzXFxuICAgIDogVG9vbHRpcDtcXG5cXG4gIHJldHVybiAoXFxuICAgIDw+XFxuICAgICAgPGRpdlxcbiAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XFxuICAgICAgICBjbGFzc05hbWU9XFxcInRvb2x0aXAtZXhhbXBsZVxcXCJcXG4gICAgICAgIHN0eWxlPXt7IHdpZHRoLCBoZWlnaHQgfX1cXG4gICAgICAgIG9uTW91c2VNb3ZlPXtoYW5kbGVNb3VzZU1vdmV9XFxuICAgICAgICBvblRvdWNoTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxcbiAgICAgICAgb25EcmFnPXtlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9XFxuICAgICAgPlxcbiAgICAgICAge3Rvb2x0aXBPcGVuID8gKFxcbiAgICAgICAgICA8PlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cXFwicG9zaXRpb24taW5kaWNhdG9yXFxcIlxcbiAgICAgICAgICAgICAgc3R5bGU9e3tcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dG9vbHRpcExlZnQgLSBwb3NpdGlvbkluZGljYXRvclNpemUgLyAyfXB4LCAke3Rvb2x0aXBUb3AgLVxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5kaWNhdG9yU2l6ZSAvIDJ9cHgpYCxcXG4gICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XFxcImNyb3NzaGFpciBob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICAgICAgc3R5bGU9e3sgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgke3Rvb2x0aXBUb3B9cHgpYCB9fVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVxcXCJjcm9zc2hhaXIgdmVydGljYWxcXFwiXFxuICAgICAgICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7dG9vbHRpcExlZnR9cHgpYCB9fVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgPFRvb2x0aXBDb21wb25lbnRcXG4gICAgICAgICAgICAgIGtleT17TWF0aC5yYW5kb20oKX0gLy8gbmVlZGVkIGZvciBib3VuZHMgdG8gdXBkYXRlIGNvcnJlY3RseVxcbiAgICAgICAgICAgICAgbGVmdD17dG9vbHRpcExlZnR9XFxuICAgICAgICAgICAgICB0b3A9e3Rvb2x0aXBUb3B9XFxuICAgICAgICAgICAgICBzdHlsZT17dG9vbHRpcFN0eWxlc31cXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICB7dG9vbHRpcERhdGF9XFxuICAgICAgICAgICAgICA8YnIgLz5cXG4gICAgICAgICAgICAgIDxiciAvPlxcbiAgICAgICAgICAgICAgPHN0cm9uZz5sZWZ0PC9zdHJvbmc+IHt0b29sdGlwTGVmdD8udG9GaXhlZCgwKX1weCZuYnNwOyZuYnNwO1xcbiAgICAgICAgICAgICAgPHN0cm9uZz50b3A8L3N0cm9uZz4ge3Rvb2x0aXBUb3A/LnRvRml4ZWQoMCl9cHhcXG4gICAgICAgICAgICA8L1Rvb2x0aXBDb21wb25lbnQ+XFxuICAgICAgICAgIDwvPlxcbiAgICAgICAgKSA6IChcXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcIm5vLXRvb2x0aXBcXFwiPk1vdmUgb3IgdG91Y2ggdGhlIGNhbnZhcyB0byBzZWUgdGhlIHRvb2x0aXA8L2Rpdj5cXG4gICAgICAgICl9XFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiei1pbmRleC1idW1tZXJcXFwiPlxcbiAgICAgICAgICBJIGhhdmUgYW4gYW5ub3lpbmcgei1pbmRleC4gVHJ5Jm5ic3A7XFxuICAgICAgICAgIDxsYWJlbD5cXG4gICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgIHR5cGU9XFxcImNoZWNrYm94XFxcIlxcbiAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQ9e3JlbmRlclRvb2x0aXBJblBvcnRhbH1cXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4ge1xcbiAgICAgICAgICAgICAgICAvLyBpZiByZW5kZXJlZCBpbiBjbGlja2FibGUgY29udGFpbmVyLCBkb24ndCB0cmlnZ2VyIHRoYXQgZXZlbnRcXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgc2V0UmVuZGVyVG9vbHRpcEluUG9ydGFsKCFyZW5kZXJUb29sdGlwSW5Qb3J0YWwpO1xcbiAgICAgICAgICAgICAgfX1cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICZuYnNwO3JlbmRlcmluZyBpbiBQb3J0YWxcXG4gICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgIDxzcGFuIHJvbGU9XFxcImltZ1xcXCIgYXJpYS1sYWJlbD1cXFwieWF5XFxcIj5cXG4gICAgICAgICAgICDwn6WzXFxuICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIHtzaG93Q29udHJvbHMgJiYgKFxcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcInRvb2x0aXAtY29udHJvbHNcXFwiPlxcbiAgICAgICAgICA8bGFiZWw+XFxuICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICB0eXBlPVxcXCJjaGVja2JveFxcXCJcXG4gICAgICAgICAgICAgIGNoZWNrZWQ9e3Rvb2x0aXBTaG91bGREZXRlY3RCb3VuZHN9XFxuICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0VG9vbHRpcFNob3VsZERldGVjdEJvdW5kcyghdG9vbHRpcFNob3VsZERldGVjdEJvdW5kcyl9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAmbmJzcDtUb29sdGlwIHdpdGggYm91bmRhcnkgZGV0ZWN0aW9uXFxuICAgICAgICAgIDwvbGFiZWw+XFxuXFxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gaGlkZVRvb2x0aXAoKX0+SGlkZSB0b29sdGlwPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICApfVxcbiAgICAgIDxzdHlsZT57YFxcbiAgICAgICAgLnRvb2x0aXAtZXhhbXBsZSB7XFxuICAgICAgICAgIHotaW5kZXg6IDA7XFxuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMTZweDtcXG4gICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAjNmM1YjdiLCAjYzA2Yzg0LCAjZjY3MjgwKTtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICB9XFxuICAgICAgICAudG9vbHRpcC1jb250cm9scyBsYWJlbCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxuICAgICAgICB9XFxuICAgICAgICAucG9zaXRpb24taW5kaWNhdG9yIHtcXG4gICAgICAgICAgd2lkdGg6ICR7cG9zaXRpb25JbmRpY2F0b3JTaXplfXB4O1xcbiAgICAgICAgICBoZWlnaHQ6ICR7cG9zaXRpb25JbmRpY2F0b3JTaXplfXB4O1xcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgICAgICAgIGJhY2tncm91bmQ6ICMzNTQ3N2Q7XFxuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC5jcm9zc2hhaXIge1xcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgIHRvcDogMDtcXG4gICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIH1cXG4gICAgICAgIC5jcm9zc2hhaXIuaG9yaXpvbnRhbCB7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBoZWlnaHQ6IDFweDtcXG4gICAgICAgICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjMzU0NzdkO1xcbiAgICAgICAgfVxcbiAgICAgICAgLmNyb3NzaGFpci52ZXJ0aWNhbCB7XFxuICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgd2lkdGg6IDFweDtcXG4gICAgICAgICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzM1NDc3ZDtcXG4gICAgICAgIH1cXG4gICAgICAgIC5uby10b29sdGlwIHtcXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICBsZWZ0OiA1MCU7XFxuICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC56LWluZGV4LWJ1bW1lciB7XFxuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgcmlnaHQ6IDEyJTtcXG4gICAgICAgICAgYm90dG9tOiAyMCU7XFxuICAgICAgICAgIG1heC13aWR0aDogMTkwcHg7XFxuICAgICAgICAgIHotaW5kZXg6IDIwMDA7XFxuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcXG4gICAgICAgICAgY29sb3I6ICMzNTQ3N2Q7XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgICAgICAgcGFkZGluZzogMTZweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMmVtO1xcbiAgICAgICAgfVxcbiAgICAgIGB9PC9zdHlsZT5cXG4gICAgPC8+XFxuICApO1xcbn1cXG5cIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/raw-loader/dist/cjs.js!./src/sandboxes/visx-tooltip/Example.tsx\n");

/***/ }),

/***/ "./src/sandboxes/visx-tooltip/Example.tsx":
/*!************************************************!*\
  !*** ./src/sandboxes/visx-tooltip/Example.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Example; });\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _visx_tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visx/tooltip */ \"../visx-tooltip/esm/index.js\");\n\n\nvar _jsxFileName = \"/Users/harry/dev/visx/packages/visx-demo/src/sandboxes/visx-tooltip/Example.tsx\",\n    _s = $RefreshSig$();\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\nvar positionIndicatorSize = 8;\n\nvar tooltipStyles = _objectSpread(_objectSpread({}, _visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"defaultStyles\"]), {}, {\n  backgroundColor: 'rgba(53,71,125,0.8)',\n  color: 'white',\n  width: 152,\n  height: 72,\n  padding: 12\n});\n\nfunction Example(_ref) {\n  _s();\n\n  var width = _ref.width,\n      height = _ref.height,\n      _ref$showControls = _ref.showControls,\n      showControls = _ref$showControls === void 0 ? true : _ref$showControls;\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(true),\n      tooltipShouldDetectBounds = _useState[0],\n      setTooltipShouldDetectBounds = _useState[1];\n\n  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(false),\n      renderTooltipInPortal = _useState2[0],\n      setRenderTooltipInPortal = _useState2[1];\n\n  var _useTooltipInPortal = Object(_visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"useTooltipInPortal\"])({\n    scroll: true,\n    detectBounds: tooltipShouldDetectBounds\n  }),\n      containerRef = _useTooltipInPortal.containerRef,\n      containerBounds = _useTooltipInPortal.containerBounds,\n      TooltipInPortal = _useTooltipInPortal.TooltipInPortal;\n\n  var _useTooltip = Object(_visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"useTooltip\"])({\n    // initial tooltip state\n    tooltipOpen: true,\n    tooltipLeft: width / 3,\n    tooltipTop: height / 3,\n    tooltipData: 'Move me with your mouse or finger'\n  }),\n      showTooltip = _useTooltip.showTooltip,\n      hideTooltip = _useTooltip.hideTooltip,\n      tooltipOpen = _useTooltip.tooltipOpen,\n      tooltipData = _useTooltip.tooltipData,\n      _useTooltip$tooltipLe = _useTooltip.tooltipLeft,\n      tooltipLeft = _useTooltip$tooltipLe === void 0 ? 0 : _useTooltip$tooltipLe,\n      _useTooltip$tooltipTo = _useTooltip.tooltipTop,\n      tooltipTop = _useTooltip$tooltipTo === void 0 ? 0 : _useTooltip$tooltipTo; // event handlers\n\n\n  var handleMouseMove = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useCallback\"])(function (event) {\n    // coordinates should be relative to the container in which Tooltip is rendered\n    var containerX = ('clientX' in event ? event.clientX : 0) - containerBounds.left;\n    var containerY = ('clientY' in event ? event.clientY : 0) - containerBounds.top;\n    showTooltip({\n      tooltipLeft: containerX,\n      tooltipTop: containerY,\n      tooltipData: tooltipShouldDetectBounds ? 'I detect my container boundary' : 'I will get clipped by my container'\n    });\n  }, [showTooltip, tooltipShouldDetectBounds, containerBounds]);\n  var TooltipComponent = renderTooltipInPortal ? TooltipInPortal : tooltipShouldDetectBounds ? _visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"TooltipWithBounds\"] : _visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"Tooltip\"];\n  return __jsx(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, __jsx(\"div\", {\n    ref: containerRef,\n    className: \"tooltip-example\",\n    style: {\n      width: width,\n      height: height\n    },\n    onMouseMove: handleMouseMove,\n    onTouchMove: handleMouseMove,\n    onDrag: function onDrag(e) {\n      return e.stopPropagation();\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 7\n    }\n  }, tooltipOpen ? __jsx(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, __jsx(\"div\", {\n    className: \"position-indicator\",\n    style: {\n      transform: \"translate(\".concat(tooltipLeft - positionIndicatorSize / 2, \"px, \").concat(tooltipTop - positionIndicatorSize / 2, \"px)\")\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 89,\n      columnNumber: 13\n    }\n  }), __jsx(\"div\", {\n    className: \"crosshair horizontal\",\n    style: {\n      transform: \"translateY(\".concat(tooltipTop, \"px)\")\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 13\n    }\n  }), __jsx(\"div\", {\n    className: \"crosshair vertical\",\n    style: {\n      transform: \"translateX(\".concat(tooltipLeft, \"px)\")\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 13\n    }\n  }), __jsx(TooltipComponent, {\n    key: Math.random() // needed for bounds to update correctly\n    ,\n    left: tooltipLeft,\n    top: tooltipTop,\n    style: tooltipStyles,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 13\n    }\n  }, tooltipData, __jsx(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 15\n    }\n  }), __jsx(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 15\n    }\n  }), __jsx(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 15\n    }\n  }, \"left\"), \" \", tooltipLeft === null || tooltipLeft === void 0 ? void 0 : tooltipLeft.toFixed(0), \"px\\xA0\\xA0\", __jsx(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 15\n    }\n  }, \"top\"), \" \", tooltipTop === null || tooltipTop === void 0 ? void 0 : tooltipTop.toFixed(0), \"px\")) : __jsx(\"div\", {\n    className: \"no-tooltip\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 118,\n      columnNumber: 11\n    }\n  }, \"Move or touch the canvas to see the tooltip\"), __jsx(\"div\", {\n    className: \"z-index-bummer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 9\n    }\n  }, \"I have an annoying z-index. Try\\xA0\", __jsx(\"label\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 11\n    }\n  }, __jsx(\"input\", {\n    type: \"checkbox\",\n    defaultChecked: renderTooltipInPortal,\n    onClick: function onClick(e) {\n      // if rendered in clickable container, don't trigger that event\n      e.stopPropagation();\n      setRenderTooltipInPortal(!renderTooltipInPortal);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 13\n    }\n  }), \"\\xA0rendering in Portal\"), \"\\xA0\", __jsx(\"span\", {\n    role: \"img\",\n    \"aria-label\": \"yay\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 11\n    }\n  }, \"\\uD83E\\uDD73\"))), showControls && __jsx(\"div\", {\n    className: \"tooltip-controls\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 141,\n      columnNumber: 9\n    }\n  }, __jsx(\"label\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 11\n    }\n  }, __jsx(\"input\", {\n    type: \"checkbox\",\n    checked: tooltipShouldDetectBounds,\n    onChange: function onChange() {\n      return setTooltipShouldDetectBounds(!tooltipShouldDetectBounds);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 143,\n      columnNumber: 13\n    }\n  }), \"\\xA0Tooltip with boundary detection\"), __jsx(\"button\", {\n    onClick: function onClick() {\n      return hideTooltip();\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 151,\n      columnNumber: 11\n    }\n  }, \"Hide tooltip\")), __jsx(\"style\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 7\n    }\n  }, \"\\n        .tooltip-example {\\n          z-index: 0;\\n          position: relative;\\n          overflow: hidden;\\n          border-radius: 16px;\\n          background: linear-gradient(45deg, #6c5b7b, #c06c84, #f67280);\\n          font-size: 14px;\\n          color: white;\\n          width: 100%;\\n          height: 100%;\\n        }\\n        .tooltip-controls label {\\n          font-size: 14px;\\n          margin-right: 8px;\\n        }\\n        .position-indicator {\\n          width: \".concat(positionIndicatorSize, \"px;\\n          height: \").concat(positionIndicatorSize, \"px;\\n          border-radius: 50%;\\n          background: #35477d;\\n          position: absolute;\\n        }\\n        .crosshair {\\n          position: absolute;\\n          top: 0;\\n          left: 0;\\n        }\\n        .crosshair.horizontal {\\n          width: 100%;\\n          height: 1px;\\n          border-top: 1px dashed #35477d;\\n        }\\n        .crosshair.vertical {\\n          height: 100%;\\n          width: 1px;\\n          border-left: 1px dashed #35477d;\\n        }\\n        .no-tooltip {\\n          position: absolute;\\n          left: 50%;\\n          top: 50%;\\n          transform: translate(-50%, -50%);\\n        }\\n        .z-index-bummer {\\n          position: absolute;\\n          right: 12%;\\n          bottom: 20%;\\n          max-width: 190px;\\n          z-index: 2000;\\n          background: rgba(255, 255, 255, 0.8);\\n          color: #35477d;\\n          border-radius: 8px;\\n          padding: 16px;\\n          line-height: 1.2em;\\n        }\\n      \")));\n}\n\n_s(Example, \"Rm9v8hG6+D6VtDorZPPWOeFYU+E=\", false, function () {\n  return [_visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"useTooltipInPortal\"], _visx_tooltip__WEBPACK_IMPORTED_MODULE_2__[\"useTooltip\"]];\n});\n\n_c = Example;\n\ntry {\n  // @ts-ignore\n  Example.displayName = \"Example\"; // @ts-ignore\n\n  Example.__docgenInfo = {\n    \"description\": \"\",\n    \"displayName\": \"Example\",\n    \"props\": {\n      \"width\": {\n        \"defaultValue\": null,\n        \"description\": \"\",\n        \"name\": \"width\",\n        \"required\": true,\n        \"type\": {\n          \"name\": \"number\"\n        }\n      },\n      \"height\": {\n        \"defaultValue\": null,\n        \"description\": \"\",\n        \"name\": \"height\",\n        \"required\": true,\n        \"type\": {\n          \"name\": \"number\"\n        }\n      },\n      \"showControls\": {\n        \"defaultValue\": {\n          value: true\n        },\n        \"description\": \"\",\n        \"name\": \"showControls\",\n        \"required\": false,\n        \"type\": {\n          \"name\": \"boolean | undefined\"\n        }\n      }\n    }\n  }; // @ts-ignore\n\n  if (typeof STORYBOOK_REACT_CLASSES !== \"undefined\") // @ts-ignore\n    STORYBOOK_REACT_CLASSES[\"src/sandboxes/visx-tooltip/Example.tsx#Example\"] = {\n      docgenInfo: Example.__docgenInfo,\n      name: \"Example\",\n      path: \"src/sandboxes/visx-tooltip/Example.tsx#Example\"\n    };\n} catch (__react_docgen_typescript_loader_error) {}\n\nvar _c;\n\n$RefreshReg$(_c, \"Example\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/harmony-module.js */ \"../../node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NhbmRib3hlcy92aXN4LXRvb2x0aXAvRXhhbXBsZS50c3g/OWYyOCJdLCJuYW1lcyI6WyJwb3NpdGlvbkluZGljYXRvclNpemUiLCJ0b29sdGlwU3R5bGVzIiwiZGVmYXVsdFN0eWxlcyIsImJhY2tncm91bmRDb2xvciIsImNvbG9yIiwid2lkdGgiLCJoZWlnaHQiLCJwYWRkaW5nIiwiRXhhbXBsZSIsInNob3dDb250cm9scyIsInVzZVN0YXRlIiwidG9vbHRpcFNob3VsZERldGVjdEJvdW5kcyIsInNldFRvb2x0aXBTaG91bGREZXRlY3RCb3VuZHMiLCJyZW5kZXJUb29sdGlwSW5Qb3J0YWwiLCJzZXRSZW5kZXJUb29sdGlwSW5Qb3J0YWwiLCJ1c2VUb29sdGlwSW5Qb3J0YWwiLCJzY3JvbGwiLCJkZXRlY3RCb3VuZHMiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJCb3VuZHMiLCJUb29sdGlwSW5Qb3J0YWwiLCJ1c2VUb29sdGlwIiwidG9vbHRpcE9wZW4iLCJ0b29sdGlwTGVmdCIsInRvb2x0aXBUb3AiLCJ0b29sdGlwRGF0YSIsInNob3dUb29sdGlwIiwiaGlkZVRvb2x0aXAiLCJoYW5kbGVNb3VzZU1vdmUiLCJ1c2VDYWxsYmFjayIsImV2ZW50IiwiY29udGFpbmVyWCIsImNsaWVudFgiLCJsZWZ0IiwiY29udGFpbmVyWSIsImNsaWVudFkiLCJ0b3AiLCJUb29sdGlwQ29tcG9uZW50IiwiVG9vbHRpcFdpdGhCb3VuZHMiLCJUb29sdGlwIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsInRyYW5zZm9ybSIsIk1hdGgiLCJyYW5kb20iLCJ0b0ZpeGVkIiwiZGlzcGxheU5hbWUiLCJfX2RvY2dlbkluZm8iLCJ2YWx1ZSIsIlNUT1JZQk9PS19SRUFDVF9DTEFTU0VTIiwiZG9jZ2VuSW5mbyIsIm5hbWUiLCJwYXRoIiwiX19yZWFjdF9kb2NnZW5fdHlwZXNjcmlwdF9sb2FkZXJfZXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7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UCxDQVRELENBVUEsT0FBT0Msc0NBQVAsRUFBK0MsQ0FBRyIsImZpbGUiOiIuL3NyYy9zYW5kYm94ZXMvdmlzeC10b29sdGlwL0V4YW1wbGUudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIFRvb2x0aXAsXG4gIFRvb2x0aXBXaXRoQm91bmRzLFxuICB1c2VUb29sdGlwLFxuICB1c2VUb29sdGlwSW5Qb3J0YWwsXG4gIGRlZmF1bHRTdHlsZXMsXG59IGZyb20gJ0B2aXN4L3Rvb2x0aXAnO1xuXG5leHBvcnQgdHlwZSBUb29sdGlwUHJvcHMgPSB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBzaG93Q29udHJvbHM/OiBib29sZWFuO1xufTtcblxudHlwZSBUb29sdGlwRGF0YSA9IHN0cmluZztcblxuY29uc3QgcG9zaXRpb25JbmRpY2F0b3JTaXplID0gODtcblxuY29uc3QgdG9vbHRpcFN0eWxlcyA9IHtcbiAgLi4uZGVmYXVsdFN0eWxlcyxcbiAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1Myw3MSwxMjUsMC44KScsXG4gIGNvbG9yOiAnd2hpdGUnLFxuICB3aWR0aDogMTUyLFxuICBoZWlnaHQ6IDcyLFxuICBwYWRkaW5nOiAxMixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV4YW1wbGUoeyB3aWR0aCwgaGVpZ2h0LCBzaG93Q29udHJvbHMgPSB0cnVlIH06IFRvb2x0aXBQcm9wcykge1xuICBjb25zdCBbdG9vbHRpcFNob3VsZERldGVjdEJvdW5kcywgc2V0VG9vbHRpcFNob3VsZERldGVjdEJvdW5kc10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW3JlbmRlclRvb2x0aXBJblBvcnRhbCwgc2V0UmVuZGVyVG9vbHRpcEluUG9ydGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCB7IGNvbnRhaW5lclJlZiwgY29udGFpbmVyQm91bmRzLCBUb29sdGlwSW5Qb3J0YWwgfSA9IHVzZVRvb2x0aXBJblBvcnRhbCh7XG4gICAgc2Nyb2xsOiB0cnVlLFxuICAgIGRldGVjdEJvdW5kczogdG9vbHRpcFNob3VsZERldGVjdEJvdW5kcyxcbiAgfSk7XG5cbiAgY29uc3Qge1xuICAgIHNob3dUb29sdGlwLFxuICAgIGhpZGVUb29sdGlwLFxuICAgIHRvb2x0aXBPcGVuLFxuICAgIHRvb2x0aXBEYXRhLFxuICAgIHRvb2x0aXBMZWZ0ID0gMCxcbiAgICB0b29sdGlwVG9wID0gMCxcbiAgfSA9IHVzZVRvb2x0aXA8VG9vbHRpcERhdGE+KHtcbiAgICAvLyBpbml0aWFsIHRvb2x0aXAgc3RhdGVcbiAgICB0b29sdGlwT3BlbjogdHJ1ZSxcbiAgICB0b29sdGlwTGVmdDogd2lkdGggLyAzLFxuICAgIHRvb2x0aXBUb3A6IGhlaWdodCAvIDMsXG4gICAgdG9vbHRpcERhdGE6ICdNb3ZlIG1lIHdpdGggeW91ciBtb3VzZSBvciBmaW5nZXInLFxuICB9KTtcblxuICAvLyBldmVudCBoYW5kbGVyc1xuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQgfCBSZWFjdC5Ub3VjaEV2ZW50KSA9PiB7XG4gICAgICAvLyBjb29yZGluYXRlcyBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBpbiB3aGljaCBUb29sdGlwIGlzIHJlbmRlcmVkXG4gICAgICBjb25zdCBjb250YWluZXJYID0gKCdjbGllbnRYJyBpbiBldmVudCA/IGV2ZW50LmNsaWVudFggOiAwKSAtIGNvbnRhaW5lckJvdW5kcy5sZWZ0O1xuICAgICAgY29uc3QgY29udGFpbmVyWSA9ICgnY2xpZW50WScgaW4gZXZlbnQgPyBldmVudC5jbGllbnRZIDogMCkgLSBjb250YWluZXJCb3VuZHMudG9wO1xuXG4gICAgICBzaG93VG9vbHRpcCh7XG4gICAgICAgIHRvb2x0aXBMZWZ0OiBjb250YWluZXJYLFxuICAgICAgICB0b29sdGlwVG9wOiBjb250YWluZXJZLFxuICAgICAgICB0b29sdGlwRGF0YTogdG9vbHRpcFNob3VsZERldGVjdEJvdW5kc1xuICAgICAgICAgID8gJ0kgZGV0ZWN0IG15IGNvbnRhaW5lciBib3VuZGFyeSdcbiAgICAgICAgICA6ICdJIHdpbGwgZ2V0IGNsaXBwZWQgYnkgbXkgY29udGFpbmVyJyxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3Nob3dUb29sdGlwLCB0b29sdGlwU2hvdWxkRGV0ZWN0Qm91bmRzLCBjb250YWluZXJCb3VuZHNdLFxuICApO1xuXG4gIGNvbnN0IFRvb2x0aXBDb21wb25lbnQgPSByZW5kZXJUb29sdGlwSW5Qb3J0YWxcbiAgICA/IFRvb2x0aXBJblBvcnRhbFxuICAgIDogdG9vbHRpcFNob3VsZERldGVjdEJvdW5kc1xuICAgID8gVG9vbHRpcFdpdGhCb3VuZHNcbiAgICA6IFRvb2x0aXA7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdlxuICAgICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgICAgY2xhc3NOYW1lPVwidG9vbHRpcC1leGFtcGxlXCJcbiAgICAgICAgc3R5bGU9e3sgd2lkdGgsIGhlaWdodCB9fVxuICAgICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgICBvblRvdWNoTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgICBvbkRyYWc9e2UgPT4gZS5zdG9wUHJvcGFnYXRpb24oKX1cbiAgICAgID5cbiAgICAgICAge3Rvb2x0aXBPcGVuID8gKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInBvc2l0aW9uLWluZGljYXRvclwiXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dG9vbHRpcExlZnQgLSBwb3NpdGlvbkluZGljYXRvclNpemUgLyAyfXB4LCAke3Rvb2x0aXBUb3AgLVxuICAgICAgICAgICAgICAgICAgcG9zaXRpb25JbmRpY2F0b3JTaXplIC8gMn1weClgLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY3Jvc3NoYWlyIGhvcml6b250YWxcIlxuICAgICAgICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7dG9vbHRpcFRvcH1weClgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjcm9zc2hhaXIgdmVydGljYWxcIlxuICAgICAgICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7dG9vbHRpcExlZnR9cHgpYCB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxUb29sdGlwQ29tcG9uZW50XG4gICAgICAgICAgICAgIGtleT17TWF0aC5yYW5kb20oKX0gLy8gbmVlZGVkIGZvciBib3VuZHMgdG8gdXBkYXRlIGNvcnJlY3RseVxuICAgICAgICAgICAgICBsZWZ0PXt0b29sdGlwTGVmdH1cbiAgICAgICAgICAgICAgdG9wPXt0b29sdGlwVG9wfVxuICAgICAgICAgICAgICBzdHlsZT17dG9vbHRpcFN0eWxlc31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3Rvb2x0aXBEYXRhfVxuICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgIDxzdHJvbmc+bGVmdDwvc3Ryb25nPiB7dG9vbHRpcExlZnQ/LnRvRml4ZWQoMCl9cHgmbmJzcDsmbmJzcDtcbiAgICAgICAgICAgICAgPHN0cm9uZz50b3A8L3N0cm9uZz4ge3Rvb2x0aXBUb3A/LnRvRml4ZWQoMCl9cHhcbiAgICAgICAgICAgIDwvVG9vbHRpcENvbXBvbmVudD5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5vLXRvb2x0aXBcIj5Nb3ZlIG9yIHRvdWNoIHRoZSBjYW52YXMgdG8gc2VlIHRoZSB0b29sdGlwPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiei1pbmRleC1idW1tZXJcIj5cbiAgICAgICAgICBJIGhhdmUgYW4gYW5ub3lpbmcgei1pbmRleC4gVHJ5Jm5ic3A7XG4gICAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkPXtyZW5kZXJUb29sdGlwSW5Qb3J0YWx9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmIHJlbmRlcmVkIGluIGNsaWNrYWJsZSBjb250YWluZXIsIGRvbid0IHRyaWdnZXIgdGhhdCBldmVudFxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2V0UmVuZGVyVG9vbHRpcEluUG9ydGFsKCFyZW5kZXJUb29sdGlwSW5Qb3J0YWwpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICZuYnNwO3JlbmRlcmluZyBpbiBQb3J0YWxcbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICZuYnNwO1xuICAgICAgICAgIDxzcGFuIHJvbGU9XCJpbWdcIiBhcmlhLWxhYmVsPVwieWF5XCI+XG4gICAgICAgICAgICDwn6WzXG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAge3Nob3dDb250cm9scyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9vbHRpcC1jb250cm9sc1wiPlxuICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICBjaGVja2VkPXt0b29sdGlwU2hvdWxkRGV0ZWN0Qm91bmRzfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0VG9vbHRpcFNob3VsZERldGVjdEJvdW5kcyghdG9vbHRpcFNob3VsZERldGVjdEJvdW5kcyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgJm5ic3A7VG9vbHRpcCB3aXRoIGJvdW5kYXJ5IGRldGVjdGlvblxuICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGhpZGVUb29sdGlwKCl9PkhpZGUgdG9vbHRpcDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICA8c3R5bGU+e2BcbiAgICAgICAgLnRvb2x0aXAtZXhhbXBsZSB7XG4gICAgICAgICAgei1pbmRleDogMDtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiAxNnB4O1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg0NWRlZywgIzZjNWI3YiwgI2MwNmM4NCwgI2Y2NzI4MCk7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICAgICAgLnRvb2x0aXAtY29udHJvbHMgbGFiZWwge1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgfVxuICAgICAgICAucG9zaXRpb24taW5kaWNhdG9yIHtcbiAgICAgICAgICB3aWR0aDogJHtwb3NpdGlvbkluZGljYXRvclNpemV9cHg7XG4gICAgICAgICAgaGVpZ2h0OiAke3Bvc2l0aW9uSW5kaWNhdG9yU2l6ZX1weDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgYmFja2dyb3VuZDogIzM1NDc3ZDtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIH1cbiAgICAgICAgLmNyb3NzaGFpciB7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB9XG4gICAgICAgIC5jcm9zc2hhaXIuaG9yaXpvbnRhbCB7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgaGVpZ2h0OiAxcHg7XG4gICAgICAgICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjMzU0NzdkO1xuICAgICAgICB9XG4gICAgICAgIC5jcm9zc2hhaXIudmVydGljYWwge1xuICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICB3aWR0aDogMXB4O1xuICAgICAgICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICMzNTQ3N2Q7XG4gICAgICAgIH1cbiAgICAgICAgLm5vLXRvb2x0aXAge1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIH1cbiAgICAgICAgLnotaW5kZXgtYnVtbWVyIHtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgcmlnaHQ6IDEyJTtcbiAgICAgICAgICBib3R0b206IDIwJTtcbiAgICAgICAgICBtYXgtd2lkdGg6IDE5MHB4O1xuICAgICAgICAgIHotaW5kZXg6IDIwMDA7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICAgIGNvbG9yOiAjMzU0NzdkO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICBwYWRkaW5nOiAxNnB4O1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjJlbTtcbiAgICAgICAgfVxuICAgICAgYH08L3N0eWxlPlxuICAgIDwvPlxuICApO1xufVxudHJ5IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgRXhhbXBsZS5kaXNwbGF5TmFtZSA9IFwiRXhhbXBsZVwiO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBFeGFtcGxlLl9fZG9jZ2VuSW5mbyA9IHsgXCJkZXNjcmlwdGlvblwiOiBcIlwiLCBcImRpc3BsYXlOYW1lXCI6IFwiRXhhbXBsZVwiLCBcInByb3BzXCI6IHsgXCJ3aWR0aFwiOiB7IFwiZGVmYXVsdFZhbHVlXCI6IG51bGwsIFwiZGVzY3JpcHRpb25cIjogXCJcIiwgXCJuYW1lXCI6IFwid2lkdGhcIiwgXCJyZXF1aXJlZFwiOiB0cnVlLCBcInR5cGVcIjogeyBcIm5hbWVcIjogXCJudW1iZXJcIiB9IH0sIFwiaGVpZ2h0XCI6IHsgXCJkZWZhdWx0VmFsdWVcIjogbnVsbCwgXCJkZXNjcmlwdGlvblwiOiBcIlwiLCBcIm5hbWVcIjogXCJoZWlnaHRcIiwgXCJyZXF1aXJlZFwiOiB0cnVlLCBcInR5cGVcIjogeyBcIm5hbWVcIjogXCJudW1iZXJcIiB9IH0sIFwic2hvd0NvbnRyb2xzXCI6IHsgXCJkZWZhdWx0VmFsdWVcIjogeyB2YWx1ZTogdHJ1ZSB9LCBcImRlc2NyaXB0aW9uXCI6IFwiXCIsIFwibmFtZVwiOiBcInNob3dDb250cm9sc1wiLCBcInJlcXVpcmVkXCI6IGZhbHNlLCBcInR5cGVcIjogeyBcIm5hbWVcIjogXCJib29sZWFuIHwgdW5kZWZpbmVkXCIgfSB9IH0gfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBTVE9SWUJPT0tfUkVBQ1RfQ0xBU1NFUyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBTVE9SWUJPT0tfUkVBQ1RfQ0xBU1NFU1tcInNyYy9zYW5kYm94ZXMvdmlzeC10b29sdGlwL0V4YW1wbGUudHN4I0V4YW1wbGVcIl0gPSB7IGRvY2dlbkluZm86IEV4YW1wbGUuX19kb2NnZW5JbmZvLCBuYW1lOiBcIkV4YW1wbGVcIiwgcGF0aDogXCJzcmMvc2FuZGJveGVzL3Zpc3gtdG9vbHRpcC9FeGFtcGxlLnRzeCNFeGFtcGxlXCIgfTtcbn1cbmNhdGNoIChfX3JlYWN0X2RvY2dlbl90eXBlc2NyaXB0X2xvYWRlcl9lcnJvcikgeyB9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/sandboxes/visx-tooltip/Example.tsx\n");

/***/ })

})